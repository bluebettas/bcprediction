# -*- coding: utf-8 -*-
"""Breast Cancer Prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s1NWjpgVNERmknhueDRj3_dcARk7Rgtt
"""

#import library
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

#panggil dataset ke dataframe
df = pd.read_csv('breastcancer.csv')
pd.set_option('display.max_columns', 33)

"""###DATA PREPROCESSING & EXPLORATORY DATA ANALYSIS

"""

df.head()

# dimensi data
df.shape

# list semua variabel dan data type-nya
df.info(verbose=True, show_counts=True)

# Mengubah tipe data diagnosis menjadi int
df['diagnosis'].replace(['M', 'B'], [1, 0], inplace=True)

# Menghapus kolom 'id' dan 'Unnamed: 32' karena tidak dibutuhkan dalam analisis
df.drop(['id', 'Unnamed: 32'], axis=1, inplace=True)
df.isnull().sum()

# Mengecek apakah ada duplikasi data
df.duplicated().sum()

# Melakukan analisis deskriptif pada data
df.describe().T

sns.countplot(x='diagnosis', data=df)

"""1 = Malignant (ganas)

0 = Benign (jinak)


---


Berdasarkan grafik di atas, dapat diketahui bahwa jumlah pasien dengan tumor payudara jinak lebih banyak dibanding dengan pasian dengan tumor payudara ganas
"""

# Correlation matrix
plt.figure(figsize=(20,20), dpi=300, tight_layout=True)
sns.heatmap(df.corr(), annot=True, cmap="viridis")

# Korelasi masing-masing variabel dengan variabel 'diagnosis'
correlations = df.corr()['diagnosis'].sort_values(ascending=False).round(2)
correlations

#normalized dataset
from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler()
col = df.columns
df[col] = pd.DataFrame(scaler.fit_transform(df[col]))
df.head()

#nilai quartil pada data train
Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1

#definisikan fungsi untuk mengecek outlier
def outlier_detect(df, col):
    q1_col = Q1[col]
    iqr_col = IQR[col]
    q3_col = Q3[col]
    return df[((df[col] < (q1_col - 1.5 * iqr_col)) |(df[col] > (q3_col + 1.5 * iqr_col)))]

# ----------------------------------------------------------
def lower_outlier(df, col):
    q1_col = Q1[col]
    iqr_col = IQR[col]
    q3_col = Q3[col]
    lower = df[(df[col] < (q1_col - 1.5 * iqr_col))]
    return lower

# ----------------------------------------------------------
def upper_outlier(df, col):
    q1_col = Q1[col]
    iqr_col = IQR[col]
    q3_col = Q3[col]
    upper = df[(df[col] > (q3_col + 1.5 * iqr_col))]
    return upper

#mengecek jumlah outlier pada setiap variabel numeric
col_names = df.columns
for i in range(len(col_names)):
    print("{}: {}".format(col_names[i],(outlier_detect(df,col_names[i]).shape[0])))

#mendefinisikan fungsi untuk mereplace/mengganti nilai upper outlier menjadi nilai maksimum
def replace_upper(df, col):
    q1_col = Q1[col]
    iqr_col = IQR[col]
    q3_col = Q3[col]
    upper = q3_col + 1.5 * iqr_col
    df[col] = df[col].where(lambda x: (x < (upper)))
    df[col] = df[col].replace(upper)

#memanggil fungsi replace upper outlier untuk setiap variabel numerik
for i in range(len(col_names)):
    replace_upper(df, col_names[i])

#mendefinisikan fungsi untuk mereplace/mengganti nilai lower outlier menjadi nilai minimum
def replace_lower(df, col):
    q1_col = Q1[col]
    iqr_col = IQR[col]
    q3_col = Q3[col]
    lower = q1_col - 1.5 * iqr_col
    df[col] = df[col].where(lambda x: (x > (lower)))
    df[col] = df[col].replace(lower)

#memanggil fungsi replace lower outlier untuk setiap variabel numerik
for i in range(len(col_names)):
    replace_lower(df, col_names[i])

#mengecek jumlah outlier untuk setiap variabel numerik setelah replace outlier
for i in range(len(col_names)):
    print("{}: {}".format(col_names[i],(outlier_detect(df,col_names[i]).shape[0])))

#mengecek jumlah nilai null pada variabel kategorik setelah handling missing value
df.isnull().sum()

#mendefinisikan fungsi untuk handling missing value menjadi nilai modus
def replace_mode(df, col):
    df[col] = df[col].fillna(df[col].mode()[0])
    print("NaN in {} raplaced with {}".format(col, df[col].mode()[0]))

#handling missing value variabel kategorik menggunakan modus
for i in range(len(col_names)):
    replace_mode(df, col_names[i])

df.head()

"""###FINAL"""

from google.colab import files
df.to_csv('bcoutput.csv', encoding = 'utf-8-sig')
files.download('bcoutput.csv')

"""### MODELLING"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Memisahkan data train dan test
x = df.drop('diagnosis', axis=1)
y = df['diagnosis']

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=101)

# Logistic Regression Model
from sklearn.linear_model import LogisticRegression
from sklearn import metrics
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=0)
logreg = LogisticRegression(solver='lbfgs', max_iter=1000)
logreg.fit(x_train, y_train)

# Memprediksi hasil dataset tes dan menghitung akurasi
y_pred_logit = logreg.predict(x_test)

# Evaluasi model menggunakan confusion matrix
confusion_matrix = pd.crosstab(y_test, y_pred_logit, rownames=['Actual'], colnames=['Predicted'])
print(confusion_matrix)

sns.heatmap(confusion_matrix, annot=True)
plt.show()

# Mengevaluasi akurasi metrik
from sklearn import metrics
print('Accuracy of logistic regression classifier on test set: {:.2f}'.format(logreg.score(x_test, y_test)))